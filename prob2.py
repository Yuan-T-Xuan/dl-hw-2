# -*- coding: utf-8 -*-
"""dl-hw-prob2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NmAcGq0YvaRgW8fzDAdxtZrMol7U0jOV
"""

"""
!pwd
!ls

!wget http://www.robots.ox.ac.uk/~vgg/data/pets/data/images.tar.gz
!wget http://www.robots.ox.ac.uk/~vgg/data/pets/data/annotations.tar.gz
!tar -xzf annotations.tar.gz
!tar -xzf images.tar.gz
!ls

!mkdir /content/images/train
!mkdir /content/images/test
"""

import os

trainval_txt_path = "/content/annotations/trainval.txt"
test_txt_path = "/content/annotations/test.txt"
image_folder = "/content/images/"
target_folder_train = "/content/images/train/"
target_folder_test = "/content/images/test/"

trainval_txt = open(trainval_txt_path)
lines = trainval_txt.readlines()
trainval_txt.close()
for line in lines:
    l = line.split()
    curr_filename = l[0] + ".jpg"
    curr_class = l[1]
    if not os.path.isdir(target_folder_train + curr_class):
        os.mkdir(target_folder_train + curr_class)
    os.rename(
        image_folder + curr_filename, 
        target_folder_train + curr_class + "/" + curr_filename
    )

test_txt = open(test_txt_path)
lines = test_txt.readlines()
test_txt.close()
for line in lines:
    l = line.split()
    curr_filename = l[0] + ".jpg"
    curr_class = l[1]
    if not os.path.isdir(target_folder_test + curr_class):
        os.mkdir(target_folder_test + curr_class)
    os.rename(
        image_folder + curr_filename, 
        target_folder_test + curr_class + "/" + curr_filename
    )

from collections import OrderedDict
import numpy as np
import matplotlib.pyplot as plt
import torch
from torch import optim, nn
from torchvision import datasets, models, transforms
from PIL import Image

class LinearNet(nn.Module):
    def __init__(self):
        super(LinearNet, self).__init__()
        self.fc1 = nn.Linear(4096, 37)
    
    def forward(self, x):
        return self.fc1(x)


def vgg19_without_last_layer():
    vgg19 = models.vgg19(pretrained=True)
    new_classifier = torch.nn.Sequential(
        vgg19.classifier[0],
        vgg19.classifier[1],
        vgg19.classifier[3],
        vgg19.classifier[4]
    )
    vgg19.classifier = new_classifier
    vgg19 = vgg19.eval()
    return vgg19

def get_pet_dataloaders():
    data_transforms = {
        'train': transforms.Compose([
            transforms.Resize(256),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ]),
        'test': transforms.Compose([
            transforms.Resize(256),
            transforms.CenterCrop(224),
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ]),
    }
    data_dir = 'images'
    image_datasets = {
        x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x])
        for x in ['train', 'test']
    }
    dataloaders = {
        x: torch.utils.data.DataLoader(
            image_datasets[x], batch_size=40, shuffle=True, num_workers=8)
        for x in ['train', 'test']
    }
    return dataloaders

linearnet = LinearNet().cuda()
criterion = nn.CrossEntropyLoss().cuda()
optimizer = optim.SGD(linearnet.parameters(), lr=0.05, momentum=0.8)

dloader = get_pet_dataloaders()
trainloader = dloader['train']
testloader = dloader['test']
vgg = vgg19_without_last_layer().cuda()

### actually, this block has been executed several times
NUM_EPOCHS = 5
optimizer = optim.SGD(linearnet.parameters(), lr=0.01, momentum=0.8)
for epoch in range(NUM_EPOCHS):
    for i, data in enumerate(trainloader, 0):
        inputs, labels = data
        inputs = inputs.cuda()
        labels = labels.cuda()
        inputs = vgg(inputs)
        q = torch.norm(inputs, dim=1)
        q = q.reshape((len(q), 1)).detach()
        inputs = inputs / q
        optimizer.zero_grad()
        outputs = linearnet(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        if i % 10 == 0:
            print('[%5d, %5d] loss: %.3f' % (epoch + 1, i + 1, loss.item()))
###

correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        images = images.cuda()
        labels = labels.cuda()
        inputs = vgg(images)
        q = torch.norm(inputs, dim=1)
        q = q.reshape((len(q), 1))
        inputs = inputs / q
        outputs = linearnet(inputs)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(correct)
print(total)
print(correct / total)

correct_per_class = [0] * 37
total_per_class = [0] * 37
with torch.no_grad():
    for data in testloader:
        images, labels = data
        images = images.cuda()
        inputs = vgg(images)
        q = torch.norm(inputs, dim=1)
        q = q.reshape((len(q), 1))
        inputs = inputs / q
        outputs = linearnet(inputs)
        _, predicted = torch.max(outputs.data, 1)
        predicted = predicted.tolist()
        labels = labels.tolist()
        for j, label in enumerate(labels):
            curr_pred = predicted[j]
            total_per_class[label] += 1
            if label == curr_pred:
                correct_per_class[label] += 1
print(correct_per_class)
print(total_per_class)
print(np.mean(np.array(correct_per_class) / np.array(total_per_class)))

